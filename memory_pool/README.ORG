* 内存池
  (Memory Pool)是一种内存分配方式。通常我们习惯直接使用new、malloc等API申请分配内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。
** 引言
   C/C++下内存管理是让几乎每一个程序员头疼的问题，分配足够的内存、追踪内存的分配、在不需要的时候释放内存——这个任务相当复杂。而直接使用系统调用malloc/free、new/delete进行内存分配和释放，有以下弊端：
   1. 调用malloc/new, 系统需要根据“最先匹配”、“最优匹配”或其他算法在内存空闲块表中查找一块空闲内存，调用free/delete, 系统可能需要合并空闲内存块，这些会产生额外开销。
   2. 频繁使用时会产生大量内存碎片，从而降低程序运行效率。
   3. 容易造成内存泄漏。
   内存池(memory pool)是代替直接调用malloc/free、new/delete进行内存管理的常用方法，当我们申请内存空间时，首先到我们的内存池中查找合适的内存块，而不是直接向操作系统申请，优势在于：
   1. 比malloc/free进行内存申请/释放的方式快。
   2. 不会产生或很少产生堆碎片。
   3. 可避免内存泄漏。
** 内存池设计
   看到内存池好处这么多，是不是恨不能马上抛弃malloc/free，投奔内存池的怀抱呢？且慢，在我们自己动手实现内存池之前还需要明确以下几个问题：
   1. 内存池的空间如何获得？是程序启动时分配一大块空间还是程序运行中按需求分配？
   2. 内存池对到来的内存申请，有没有大小的限制？如果有，最小可申请的内存块为多大，最大的呢？
   3. 如何合理设计内存块结构，方便我们进行内存的申请、追踪和释放呢？
   4. 内存池占用越多空间，相对应其他程序能使用的内存就越少，是否要设定内存池空间的上限？设定为多少合适呢？

*** 区块内存池
    内存池的所有区块可以分为三个区域：
    无效区:这里的区块已经完全分配完毕, 等待释放, 释放完成后会到自由区
    待分配区:这个区有且只有一个块, 分配内存都会从这里抽取
    自由区:
**** 优点:
     1.分配的时候仅仅移动了指针, 内存不足时(即创建新块的时候)调用到c运行库的malloc.如果不算上malloc的话.内存池分配只需要执行少于10个指令.所以分配速度非常快。
     2.释放的时候不需要合并这个步骤.很多内存分配器都是在合并上用了很多时间.这个内存池不需要任何合并的动作。
     3.可以分配任意大小的内存.当然, 太大的时候会委托给malloc
**** 缺点:
     1.如果分配完一个区块后会造成少量碎片
     2.无效区域内的内存只有等完全释放了, 这个块才可以重用, 所以不适合长期占有内存池的内存.
     这个很大限度限制了这个内存池的实用性.
